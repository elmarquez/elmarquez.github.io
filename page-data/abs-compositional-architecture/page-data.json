{"componentChunkName":"component---src-templates-blog-post-js","path":"/abs-compositional-architecture","result":{"data":{"markdownRemark":{"html":"<p>ABS is a compositional modeling architecture that aims to facilitate design\nexploration by reducing the cost of change and by making the design process\nvisible. It comprises three foundational elements: assembly, behavior and\nscenario. These elements together form an algebra for generating design states.\nWe describe an implementation of ABS called F/M, report on our initial\nevaluation of X, Y, Z; and describe directions for future research.</p>\n<h2>Introduction</h2>\n<p>Creative design is an evolutionary activity. [0]  To increase the degree to\nwhich designers explore alternative designs, we must reduce the cost of change,\ncognitive load, while providing new functionality that aids</p>\n<p>Creativity is a predominantly social, evolutionary activity. (Csikszentmihalyi) (Gabora)\nDesigners act within a social field\nDesigners create designs through a process of iterative exploration and development.</p>\n<p>Design is puzzle making and puzzle solving (Smithers)\nWe evolve both the problem statement and the design artifact as we learn.</p>\n<p>The probability of generating a complex whole increases\nThe probability of generating novel or improved designs increases with our ability to generate design alternatives (Simon, p.472)\nSimon, others?\nComplexity accrues through hierarchy\nThe probability of building a complex system increases through hierarchy\nThe probability of discovering simultaneously novel design options increases with the number of alternative designs available. However, the cost of generating alternatives in an environment that is characterized by increasing complexity and reduced time impedes the ability of designers to produce alternatives.\nEvolutionary argument\nProbability of novelty increases with the number of variations produced</p>\n<p>[the argument above is that we need exploration to increase our chances of discovering novel, satisficing designs]</p>\n<p>However, the circumstances of contemporary practice impede exploration\nProjects are growing in size and complexity\nThere is limited time to produce design work\nIt is difficult to simultaneously manage Cognitive limitations\nChange becomes exponentially more expensive as the project evolves. Design decisions create constraints and interdependencies between elements of a project. As time passes, the nature and quantity of constraints makes change  increasingly expensive.\nFor social innovation to occur, people need to be able to see the design process, to know what has been explored</p>\n<p>We need to reduce the cost of change to be able to increase the ability for designers to consider alternatives\nBy cost of change we mean the mental effort and labour time required to create designs, revise existing designs, compare and generate alternatives.\nLabor cost is the cost of generating design options, evaluating and refining designs. Expressed principally in time.\nThe cognitive cost is the cost required to manage the design as it increases in quantity and complexity</p>\n<p>Creativity is a social phenomenon\nInnovation is amplified by the ability for designers to share and remix\nContextualize/re-contextualize design systems</p>\n<p>Design is a process whereby information accrues in a project as time passes\nWe need to reduce the cost of change such that design teams can defer major decisions longer\nSo that major decisions are made when the maximum amount of information is available to support those decisions</p>\n<p>If you can get to the end of a design process and not feel like you would do the whole thing over differently then you haven’t learned anything. -- Thom Mayne</p>\n<p>Need for Explicit Support of Exploration\nCAD applications can do much to facilitate exploratory work. However, few CAD applications provide first-class support for exploration and remixing of designs. As a result, designers are forced to improvise manual workflows to track variation.</p>\n<p>We know that</p>\n<p>visualizing the design process\nCues signaling progress is play the same role in the problem-solving process that intermediary forms play in the biological evolutionary process p 472</p>\n<p>To amplify the ability of designers\nWe must reduce the cost of change. By cost, we mean the time required to generate a design, the mental effort to , the effort required to modify an existing design as changes occur.</p>\n<p>The design space is a hypothetical space.\nExploration is the process of transitioning from one position in the design space to another\nDefine making the design process visible</p>\n<p>What we want to do is:</p>\n<p>reduce cognitive load\nreduce the cost of change\nmake the exploratory process intelligible\ncreate new possibilities/features/benefits not present in other modelers</p>\n<p>ABS Architecture\nABS is a compositional modeling architecture that aims to facilitate design exploration. The building blocks of the architecture are three entities called assembly, behavior, and scenario.\nWe provide a summary description of each then describe workflows that illustrate the attributes of the ensemble.\nComponents\nAssembly\nAn assembly a is a function that, given input x, produces an output state a'representing an element of a design.</p>\n<pre><code>a: f(x) a'\n</code></pre>\n<p>An operable window is a simple example of an assembly.</p>\n<pre><code>window: f(dimensions) window object\n</code></pre>\n<p>Given dimensions for the structural frame as input, the window assembly function then produces the window geometry and associated metadata as output.</p>\n<p>Assemblies may be composed hierarchically into trees. The children of the root assembly are called sub-assemblies. The leaf nodes of the tree are non-decomposable elements called parts. In our example, the sub-assemblies of the window include the structural frame, the fixed and sliding window panels, and the interior and exterior finishing elements. The parts of the window include individual elements of the wood frame, sheets of glass, nails and screws that join elements together.</p>\n<p>An assembly instance ai is a map from the arguments xito the resultant output state a'i.</p>\n<pre><code>ai: a(xi) a'i\n</code></pre>\n<p>Where an assembly aihas more than one set of input arguments available, we denote the input argument xij and the corresponding output state a'ij.</p>\n<pre><code>ai: f(xij) a'ij\n</code></pre>\n<p>In our window example, a is the window function, xiare the window dimensions [300, 900]and a' is the resultant geometry and associated metadata.</p>\n<p>The output of an assembly function is dynamic if it varies in relation to input arguments or random variables, and static if it does not.</p>\n<p>Behavior\nA behavior bis a function that is bound to an assembly aand modifies the output of that assembly in response to changes in the environment e. Behaviors are reactive and have two parts: a condition and an action. When the condition cis true, the action o is executed. The action modifies the input arguments xior the output a'i of the assembly in response, depending on its implementation.</p>\n<pre><code>b: f(c, o, a)\n</code></pre>\n<p>A behavior instance bi binds behavior band assembly ai, and maps the bound function to the output state a'i.</p>\n<pre><code>bi: b(ai) a'i\n</code></pre>\n<p>Scenario\nScenario is a specific instantiation of assemblies and behaviors that generate a resultant design state. The members of a scenario are those elements that are considered when computing the design state. Two classes of membership exist: contextual and transactional.</p>\n<p>scenario members = contextual + transactional</p>\n<p>Contextual elements are those that exist in the world but may not be changed within the scope of the scenario. Transactional elements are those that the designer adds, edits or deletes to change the state of the world. We determine the current membership of a scenario as follows:</p>\n<p>scenario members = (econtextual - edeleted - eupdated) + eadded</p>\n<p>Scenarios may be composed hierarchically into trees. The context of the root scenario is an empty set. The context of all sub-scenarios is the predecessor scenario.</p>\n<p>The state of the design is resolved by computing the state of each member in the scenario. Execution proceeds from contextual to transactional elements. For any given scenario, the state of each contextual element is already computed. Then, transactional elements are evaluated in order of static assemblies, followed by dynamic assemblies with no behavior, and finally those assemblies with bound behaviors.</p>\n<p>ln a'i\nsn = { l0, l1,... , ln }</p>\n<p>Composing Designs\nThe aim of the architecture is to enable the designer to build a design up from simple parts while reducing the amount of labour required to develop and maintain those designs as changes occur.</p>\n<pre><code>sroot= {} + {}\n</code></pre>\n<p>For example, the first scenario in our model is sroot. Both the context and change set of this scenario are initially empty, and therefore the output state is empty. The designer then adds assembly a1to the scenario, resulting in an output state of { a'1 }.</p>\n<pre><code>sroot= {} + { a1 }\nsroot= { a1 }\n</code></pre>\n<p>The designer then creates a new scenario s1 and sets the context of the new scenario as sroot. The initial state of s1 is then { a'1 }.</p>\n<p>s1=sroot + {}\ns1= { a1 }</p>\n<p>The designer adds assemblies a2 and a3to the scenario, producing the output state { a'1, a'2, a'3 }.</p>\n<p>s1=sroot + { a2, a3 }</p>\n<p>Deleting a transactional element removes it from the transactional set. Deleting a contextual element adds its identifier to the edeleted Editing a transactional element simply retains the element as a member of eadded . However, editing of a contextual element requires a double operation. First, the element identifier is added to the edeleted set. Then, a new record is created in eadded.</p>\n<p>Comparison to existing approaches</p>\n<p>We compare our approach to established modeling paradigms of explicit, history, constraint, and data-flow or associative modeling.\nExplicit modeling is an application architecture that requires the designer to fully specify the geometric properties of modeled objects through the application user interface. Once generated, the geometry does not change unless the designer modifies it directly.\nHistory-based modeling extends direct modeling by recording the operations by which an individual object is generated. To generate the output design state, the system replays each operation in the history.\nConstraint modeling extends explicit or history based modeling to allow the designer to specific relationships (ie. constraints) between elements of the design. Once the constraint is established, the system is then responsible for enforcing the constraint or otherwise notifying the user of when it has been violated. “Whenever a part of the model is modified, the system adjusts the rest of the model such that all the user imposed constraints remain valid.” [11]\nData-flow and associative modeling bear some similarity to history based modeling in that they model the process by which an object is generated.\nEach modeling paradigm trades-off flexibility against computing resources.\nThe ways in which these approaches manage change over time\nExplicit\nThe benefit of direct modeling is the relative ease. Where changes are to occur to some aspects of an entity, the designer must manually execute those changes. However, at the size and complexity of relationships\ndefining a project grows, requires increasing amounts of work to maintain\nexisting relationships as changes occur.\nHistory based\nThis approach requires a substantial amount of up-front planning to organize, and can be challenging to revise.\nConstraint based\nData-flow\nBehavior tree\nBehavior trees generalize other control flow approaches including finite state machines, hierarchical finite state machines, subsumption architectures, and teleo-reactive systems [00]\nThey provide increased modularity, improved reactivity over these other approaches\nBT typically use a tick event as a signal to update or query state. Such events are typically based on time. However in our application the update event is a user triggered change.</p>\n<p>Composition\nHierarchy\nNear decomposability\nHierarchy as a membership structure rather than as system of containment and exclusion.\nConcern here is the management of interaction and communication\nUniversity metaphor - professors are employed by organizational units (colleges, departments, etc.) of the university but otherwise free to communicate and interact with each other.\nInteractions are strongest within\nRemixing designs, elements of reuse\nRe-contextualizing designs\nDesign ~ specificity\nHow are elements reused? What is being reused?\nGeometry\nCopy/paste\nAutoCAD blocks\nParametric objects\nOther</p>\n<p>“In problem solving, a partial result that represents recognizable progress toward the goal plays the role of a stable subassembly.” (Simon, p.472)</p>\n<p>Composition\nComposition is a powerful paradigm.\nWhat is it?\nEnables the construction of complex programs from simple parts.\nFunctional programming?</p>\n<p>The effect of the scenario is to aid the designer in managing the input data space.</p>\n<p>At a technical level, scenario provides a mechanism for computing design states. At the level of the design process, scenarios aid the designer in organizing exploratoration and reflect some aspect of their thought process. As the designer creates designs,\nThey can create new design scenarios to evolve alternative designs.\nexploratoration process while reflecting some aspect of their cognitive behavior.\nThe design context is the designer’s mental model of the design world. The designer produces designs in response to that mental model, and those designs in turn produce new information that modifies the mental model of the designer. Scenario provides an organizational\nWhen the context of the design changes, we expect that the designer will create new scenarios to reflect that changed context. An assembly instance is identified in the modeling environment by a unique identifier <code>id</code>. The identifier points to the result state the assembly.</p>\n<p>Behavior binds the state of the assembly to its environment.</p>\n<p>Representations of exploration\nRepresentations of design alternatives\nPhotoshop filter dialog\nAutodesk generative\nBlind watch maker\nRepresentations of change over time\nDesign changes come as sets and therefore a discrete change representation is relevant; or a continuous change representation is not useful. Continuous versus discrete change.</p>\n<p>In the nonvisual domain Git - changes\nIn the visual domain\nApple ?/ Lightroom\nPremiere\nDocs\nFigma or similar</p>\n<p>F/M - A Platform for Experimentation\nTo evaluate the ABS architecture, we have implemented an experimental CAD application called F/M [2]. F/M is a hybrid parametric modelling application. It provides some facility for direct modeling, in addition to the ability to program custom model elements. F/M was written in C++ and C#. It uses the C3D kernel for geometric modelling. The user interface was implemented using QT.</p>\n<p>Major application components\nAssembly, behavior base classes\nProgramming in an IDE\nDynamic .Net assembly loading\nInteractive model development similar to Lighttable, Maleki thesis</p>\n<p>We represent behaviors as behavior trees.\nPrior research in subsumption architecture. Similar to behavior trees.</p>\n<p>Use Case\nNeed an example (possibly from structural engineering group)\nExplanation of work flow</p>\n<p>Precedents\nMorphosis CCA Competition for the Design of Cities\nFederation Modeller\nComparison to Other Approaches\nDirect modeling\nConstraint modeling\nDataflow modeling\nPlasma language\nother?</p>\n<p>Composition is a powerful strategy for enabling flexible creation from simple parts.\nThe area we’ve focused our effectors\nDesign representations are partial\nThe abs architecture supports and in many ways reflects these attributes of design\nWe contend that non routine design is fundamentally\nThe goal of the architecture is to reduce the cost of developing and comparing alternative designs.</p>\n<p>Automatic production of variants\nArchitecture is an art of composites\nEvaluation</p>\n<p>Conclusions\nThe ABS architecture\nFor the functional composition of design states from reusable, adaptable units of design. Behaviors assist designers by encoding design intent.</p>\n<p>Citations\nAish, Robert. (2012). DesignScript: Origins, Explanation, Illustration. Christoph Gengnagel, Axel Kilian, Norbert Palz, and Fabian Scheurer (Eds.),\nComputational Design Modelling. Proceedings of the Design Modelling Symposium 2011 (p1-8). Berlin: Springer.\nColledanchise, Michele and Ogren, Petter. (2018) Behavior Trees in Robotics and AI, an Introduction.\nGabora, L. (2000). The beer can theory of creativity. In P. Bentley &#x26; D. Corne\n(Eds.), Creative Evolutionary Systems (pp. 147-161). San Francisco: Morgan\nKauffman.\nGamma, Eric, et. al. (1995) Design Patterns: Elements of Reusable Object-Oriented Software. DMR Group. Montreal, Canada.\nMarques, D. (2007). Federation Modeler: a Tool for Engaging Change and Complexity in Design (Graduate dissertation, Simon Fraser University, Canada). Retrieved from <a href=\"https://summit.sfu.ca/item/8114\">https://summit.sfu.ca/item/8114</a>\nMiller, George A. (1956), \"The magical number seven, plus or minus two: some limits on our capacity for processing information\", Psychological Review, 63 (2): 81–97.\nSimon, Herbert. The Architecture of Complexity. Proceedings of the American Philosophical Society, Vol. 106, No. 6, DECEMBER, 1962.\nSmithers, Tim, 1992. Design as exploration: Puzzle making and puzzle solving, in Notes for the Workshop on Exploration based models of design and search-based models of design, held as part of AI in Design ’92, Carnegie Mellon University, Pittsburgh, June 1992.\nSutherland, Ivan. SketchPad.\nWolfgang Sohrt, Beat. D Bruderlin. (1991). Interaction with Constraints in 3D Modeling. ACM. (p387-396)\nWoodbury\nWeaver, Warren. (1948) Science and complexity. American Scientist, 36(536).\nCsikszentmihalyi M. (2014) Society, Culture, and Person: A Systems View of Creativity. In: The Systems Model of Creativity. Springer, Dordrecht</p>\n<p>Notes</p>\n<p>Consider renaming Assembly to another name.\nWhy?\nSounds too concrete, restrictive, conventional\nWhat alternatives?\nComponent/Atom (as in design systems)\nResources\n<a href=\"https://en.wikipedia.org/wiki/Functional_programming\">https://en.wikipedia.org/wiki/Functional_programming</a>\n<a href=\"https://en.wikipedia.org/wiki/Subsumption_architecture\">https://en.wikipedia.org/wiki/Subsumption_architecture</a>\n<a href=\"https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29\">https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29</a>\n<a href=\"https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)#References\">https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)#References</a>\n<a href=\"https://en.wikipedia.org/wiki/Functional_reactive_programming\">https://en.wikipedia.org/wiki/Functional_reactive_programming</a>\n<a href=\"https://en.wikipedia.org/wiki/Situation_calculus\">https://en.wikipedia.org/wiki/Situation_calculus</a>\n<a href=\"https://en.wikipedia.org/wiki/Data_farming\">https://en.wikipedia.org/wiki/Data_farming</a>\n<a href=\"https://en.wikipedia.org/wiki/Bounded_rationality\">https://en.wikipedia.org/wiki/Bounded_rationality</a></p>","frontmatter":{"date":"July 12, 2017","path":"/abs-compositional-architecture","title":"ABS: a Compositional Architecture to Support Parametric Design Exploration"}}},"pageContext":{}},"staticQueryHashes":[]}